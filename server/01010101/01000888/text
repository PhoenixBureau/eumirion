Here's the process I went through to transform this into a version that has all the "arguments" to the left (on the stack) and the cunctions and combinators on the right (a program):

a sqr b sqr + c sqr = cssclass:/12345678/12395686

Let's consider just this prefix:

a sqr b sqr cssclass:/12345678/12395686

In order to move sqr in front of b we can use the dip combinator.  Its rule is:

... Q n == ... n [Q] dip cssclass:/12345678/12395686

Apply it to our program prefix:

a b [sqr] dip sqr cssclass:/12345678/12395686

So far, so good.  Let's add the rest of the program back in and see what we have so far:

a b [sqr] dip sqr + c sqr = cssclass:/12345678/12395686

We can use that same transformation again to get:

a b c [[sqr] dip sqr +] dip sqr = cssclass:/12345678/12395686

Notice that we can rearrange it a little to get something I feel is more elegant:

a b c sqr [sqr [sqr] dip +] dip = cssclass:/12345678/12395686

Isn't that nice?
css:/12345678/01010102